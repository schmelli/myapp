**LegalIDE MVP Development Prompt**

**Objective:**
Create a functional prototype for LegalIDE MVP as a web application using the Flutter framework for the frontend and the AWS ecosystem (mainly EC2, and Cloud Data using AWS Relational databases or non-relational data structures with file system management with access control via S3 bucket services and user identity control using AWS Cognito authentication). Connect UI elements using HTTP API connections. A separate Lambda function shall exist to process natural language prompts based on previous test configurations described bellow). Log system data (following GDPR rules as we specified)

**1. Core Setup**

*   Create a new Flutter web project using basic templates for main UI parts (main application header bar with text, document list, editing area on page section for the Markdown text, and an additional sidebar with document outlines using levels for section/subsections etc), as previously described. Use a responsive UI pattern and UI component library as described. Implement proper handling on each main area component so elements are separated, modular (that enables code reuse between different parts and different project setups and versioning at individual UI parts ). Create configuration files, also using a configuration parameter loading architecture (so parameters can be read from data storage or from simple hard coded strings values). Provide unit testing for code components before start. Test for any memory leaks in every part you code in all phases. Start with layout using 8 column grid structure and an “opinionated CSS default”, but separated from application core logic layers.

*   Use mock authentication for user management. Add sample documents list using data mock system object with an UUID, title, type, created, last edited user information. All data should follow all rules we provided in section `Database Model`. A UI must show this list with a button to edit existing (or to start creating a new) record with UUID identifier. Select “single window view with navigation bar for document list / selection / new documents”. All information must load by asynchronous data flow handling logic with data loading indicators while API request process to server. User can’t modify or perform system logic at all while data retrieval is still running on backend (or when back end service returns a failure). Every request should generate local system/UI logs in text to allow easier testing and problem resolution if there is any failure along the process. Never display errors if not expected. Every UI exception MUST BE CATCH by an “error handling system”, using try catch blocks on asynchronous and synchronous logic on UI systems and with log parameters also. Data security here should be also followed based on best programming practices by keeping data access by variables names, always separated from data content values, avoiding leaking internal database UUID when they don’t need to be. Use standard coding format / documentation system by each parameter definition. Every function/parameter on code component shall have comments that state the full behaviour in detail so code and application architecture become more testable and better readable (following coding standards and best programming practices as a principle on any of your code). Use descriptive names and variables with clearly specified meanings, and parameters, all with its typing system, so data model type errors may occur during dev testing cycles. Code test and refactor whenever a given section works before going on any other implementation at code layers of each component. All that at unit test levels, using small “test cases”.

**2. Markdown Editor (Text Input Module)**

*  Create a main code editor area that must:
* Receive text data from previous sections data with format data (as listed on test data bellow)

   *  Convert text in editor area to valid code data (based on given examples), applying formatting at user view (all tags should have different styles as we defined on previous markdown logic explanation), using custom tags and also using a “styling” and HTML like renderer (but decoupled form HTML if the underlying rendering system allows it). It should follow a “Component driven methodology”. Use local component caching on UI for high speed rendering if user text did not change on editor mode (as previously described for caching UI objects). Remember : perform caching if you detect performance problem at “low” UI response timings to user, after testing every interaction before production usage phases
* Implement local test markdown tag validations
    * The “validator object code” must check, the integrity of text using all of the markdown structures described previously: headers with nesting level (with maximum nested section tag on configurations), correct number for each tag, correct parameters syntax, all markdown styles tags in bold / italic, and proper mark references using all logic defined previously with UI warning styles if malformed and error log to UI console or locally available text debug log areas (and/or Cloudwatch integration)
    * Check data structures for correct parameter type if they don’t cause an application crash. Catch system wide errors (try/catch logic at each point at user event handling loops and interactions, including UI data changes), for a secure implementation workflow, and error recovery when any step does fail along the way. It will increase confidence, reliability at lower costs in code development, as it will become more flexible on changes required by test validation scenarios at testing layers
* Implements syntax highlight by all types and kinds of tags, and user input content using CSS styles and html DOM element attributes (or components provided by rendering engine), to separate different logical blocks with a different background or text formatting styles.
    * Always make use of standard css styles and class names so all team can better code each and every area without hidden logic on CSS names (or class names with unknown parameter / or unpredictable behaviours). Keep styling consistent for readability, but not hardcoded if possible (but with proper default style guide approach). Make sure if styling classes have more then 2 levels or nesting of tags it also adds up complexity on UI behaviour, so make UI render system efficient even if rendering more than one type or level of html component types

  * Code autocompletion (using only predefined system options at this stage) when “@”,”#” or other keys are pressed. Each should only “show the list” and apply the corresponding tag only by clicking an UI component from a system predefined list of items available by the current scope of editor, as a simple text completion mode when writing data. Text autocompletion and user content selection by clicking from a pre-filled set of components based on code logic should only follow previously established syntax rule validation (if not valid it must fail gracefully and only log for debugging if required)

    *   Text data entered into UI (from past states or from real time input by keyboards or similar input text devices ) MUST also always have its validations to guarantee no application crashing behaviors are happening along every user step / code flow at the given UI implementation steps and routines (as mentioned in each phase description) (or use validation before UI elements are inserted / updated if that makes the validation workflow faster in performance using asynchronous or separated “UI rendering thread “ processes). Validation error feedback shall follow style standards (visual feedback, error texts). Implement a way to skip a validation error code or to add a flag when “this error is OK” to user test all kinds of possible variations on different text configurations and testing on a workflow scenario in each implementation stage to avoid issues during production if all the rules here are also coded at a validation step and followed for that step too

**3. Database interactions and record handling.**

* Make an architecture based approach to all data objects to read , update, remove , filter entries for files / document content (text information) / user related information at the same time for performance checks and validations steps (see “Database Schema” section for definitions) using the described code logic parameters using UI indicators when information or processing from that UI module to back end and also if that database component was locally or remotelly stored in web service or a local component with proper caching strategy using pre loaded text object for better system / client and local server cache performance. Always store data offline in a way if you are unable to contact AWS remote servers. Local client data operations MUST log those offline modes in system when connectivity has not been established for system analysis, debugging reasons and also from UX feedback that those offline operations provide. Check that UI provides a different approach (if required) to user by showing that not all options are fully available during a specific offline condition, that also requires a proper error logging workflow implementation for proper security standards requirements (do not provide error if not an error from application code and logic implementation as explained earlier).

  * Provide all list / read/update/ remove parameters via a pre configured interface (using UI configuration panels for parameters or code injection points via “user interfaces” (with some form of “plug-in management capabilities to easily perform actions) at code level with specific API entrypoints that call back end logic via RESTfull services using GraphQL). Create methods that test if backend system / AI / other database connections respond before you move or rely any part of local system in that kind of operation on both frontend/backend services when the request data workflow is in use on some part of a UI section / view logic or during the user interface active flow. Check that parameters that the backend is expecting are those passed and that API return types are compliant to expected values at client/system local logic layers. Make each system’s components reliable before any more complex action workflow. Add debug points / conditional code compilation or using flags so errors can be locally controlled before hitting to users if something is going wrong when code isn't in production mode, by an internal dev or testing teams at earlier test stages. It includes error validation at code level as we have specified on other code layers
    * Store (also offline with UUID to provide synchronization mechanism ) new, removed , or changed sections via a “state management library system with local persistence database system (such as SQLite or any other lightweight format) on mobile devices in order that “unsaved work is available in the given application session context” on local mobile / web apps that you will generate with this system
     * Provide a good strategy for all components to retrieve and cache backend/client related information based on time-to-live or other relevant strategy that you have chosen. Always separate cached values and API call for each part, with local logs indicating every action performed by any sub module for further UI and system validations. That will help to locate the source for bottlenecks for proper optimization cycles at both architectural as well as component UI interactions levels, by analyzing system behaviour and resources usage at code levels (local data read , database writes, UI drawing, HTTP calls etc )

**4.  AI Suggestion Module (Based on external AWS Lambda via AWS API entrypoint and mock data mode for UI development mode)**

  * Make a very basic integration with test server mock functions first. The code should then make proper calls to AWS Lambda by sending specific JSON payloads (using specific request bodies), by all logic parts related with user / selected areas at code, user input data from local components. See AI model implementation detail parameters to ensure data consistency between the input from data object, payload transfer (which must always validate parameters being received at API level) and expected answers and responses formats that we detailed previously at prompt specifications. Error validation codes, should always return “human understandable information”. Each error should have both “a numeric code for systems to treat with code validation and logging” and also “a user-friendly string with what went wrong, without leaking hidden or private data at UI response text / error component feedback”.
 *   Code should “ask AWS for a suggestion using the text provided by Markdown Component” for current selection area, and display received messages/text using specific styles and layouts for text feedback, and give ability to user to ACCEPT/ REJECT and to copy information back to their current text by specific click on the corresponding UI element using mouse ( or touching when a screen with touch devices are available).
    *  Provide a UI for a "simple example with mockup data with text suggestions from different sources (user or third-party)” on mock local server to UI implementation phase for better control and clear feedback cycles for developers (during UI, test mode implementation cycles). The simulated API behaviour may create variations of valid/invalid / timed-out (delayed response for testing timeouts from client system calls and exception workflow managements with real network delays). Never use synchronous (or blocking main execution code thread) at any UI related operation that waits for backend response or information loading in local or remote data or from local AI models. Always implement all workflow interactions following asynchronous models and multi threading strategies.
    * Implement security using JWT token (which must be locally stored and also on browser storage for system test cycles).

**5. Output Layout Engine (Basic docx/pdf)**

*   Make an export action method for document to format text, images using markdown structure objects or similar. You must implement the base functionality by starting from JSON to string conversion, creating .DOCX / PDF output file for text layout (using either any good reliable format rendering PDF using standard LaTex engine component or simpler / native alternatives such as html conversion + css layout rendering. Never compromise text output rendering security by generating executable text code inside output files. Also for other binary object do the same validation or secure approaches (using standard image output libraries without hidden exploitable parameters in any parts of data content rendering workflows from user input to output stage to the last code call instruction chain steps).
     * Follow document layout standards by settings configurations with clear UI implementation details on parameter editing on such settings, all separated and consistent on a UI screen for managing global text, margins, and page numbers , attachment/definition lists settings to manage header / footer formats based on different PDF and docx style definitions (see output models based on document layout examples at the document test parameter settings definitions below ). UI must allow preview for these operations. Always validate and protect all parameters passed by users with backend logic validation so user cannot pass wrong formatting types at server side code components

 * All exportable document components (PDF/DOCX) must follow proper security implementations and code design for safe operations based on well tested UI / output engines when data output workflow happens. Prevent document security threats on outputs at any way, by validating for valid file signatures when possible. Document signatures using encrypted data with hash code is highly advisable. If needed, allow digital signature with certificates to ensure output integrity at security validation steps (only if it makes sense for your client's business process and code integration / configuration settings logic )

**Test Example and Data Sets**:

(Here a set of text and JSON strings, and data objects showing all types of requests that are available as examples to your coding agent, to fully understand what we expect)

  **Markdown Samples**

```markdown
# Sample Policy Document

## Section 1: Introduction

This is an example of the content of a **corporate policy** document.
We can define important terms like `@employee` to clarify their meaning later.

## Section 2: Responsibilities

This is another section that might have important points to review.

*  Employee shall use **best effort to conform policy rules**.
*    Compliance with law are crucial.

  [[file:1]] is related to specific part of the policy. And it shows below

  # section 3: Special instructions for [[IF:complianceIsRequired] ] then text is given [[ELSE:]]

      A good example for nested items should show like this.

## Terms and Definitions

  @employee :  Someone working in our company.

  This policy requires all information to be stored and managed accordingly